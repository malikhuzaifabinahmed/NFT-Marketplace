{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\ncontract ArtAlleyMarketplace {\r\n    //item structure of makrketplace\r\n    struct s_Marketpalceitem {\r\n        uint256 Price;\r\n        bool approval;\r\n    }\r\n    struct s_Marketpalceoffer{\r\n        uint256 Price;\r\n        uint256 Endtime;\r\n        }\r\n      \r\n\r\n    //@dev here owner of NFT is the address parameter\r\n    //@mapping from owner address to the total number of items related to the owner on marketplace\r\n    \r\n    mapping(address => mapping(address =>mapping(uint => s_Marketpalceitem)))\r\n        private _s_marketplaceItem;\r\n  //1st address is of the user \r\n    // second address is of collection contract\r\n    //uint is for tokenId of the NFT mapped to the struct of offer\r\n    mapping(address => mapping(address => mapping( uint256 => s_Marketpalceoffer)))\r\n        private _s_marketplaceItemoffer;\r\n    \r\n  \r\n\r\n    //@dev: event will occur when item will be created on the marketplace\r\n    event itemCreation(\r\n        address indexed owner,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        bool aproval\r\n    );\r\n    //@dev event occurs when new item is listed to be sold on marketplace\r\n    event newListingCreated(\r\n        address indexed owner,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 listingPrice\r\n    );\r\n    event updatedListing(\r\n        address indexed owner,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 listingPrice\r\n    );\r\n    event listingCancled(\r\n        address indexed owner,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId\r\n    );\r\n    //@dev event occurs when item is sold\r\n    event listingSold(\r\n        address indexed owner,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price\r\n    );\r\n\r\n    // @dev: this function is will initialise a new item on Marketplace\r\n \r\n    event offerCreated(\r\n        address indexed offerer,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 Endtime\r\n    );\r\n     event offerUpdated(\r\n        address indexed offerer,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 Endtime\r\n    );\r\n      event offerAccepted(\r\n        address indexed offerer,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 Endtime\r\n    );\r\n      event offerDeleted(\r\n        address indexed offerer,\r\n        address indexed collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 Endtime\r\n    );\r\n\r\n    function createListing(\r\n        address collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 listingPrice\r\n    ) public {\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n        require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n        require(owner == msg.sender, \"User is not the owner of the tokken\");       \r\n        require(\r\n            IERC721(collectionAddress).isApprovedForAll(\r\n                msg.sender,\r\n                address(this)\r\n            )|| (IERC721(collectionAddress).getApproved(tokenId) == address(this)              \r\n            ),\r\n            \"Marketplace is not approved to list items\"\r\n        );\r\n\r\n        s_Marketpalceitem memory item = _s_marketplaceItem[msg.sender][collectionAddress][tokenId];\r\n\r\n        if (item.Price== (0)) {\r\n            \r\n            _makeItem(collectionAddress, tokenId, listingPrice, true);\r\n        } else {\r\n            _s_marketplaceItem[msg.sender][collectionAddress][tokenId].approval = true;\r\n        }\r\n        emit newListingCreated(\r\n            msg.sender,\r\n            collectionAddress,\r\n            tokenId,\r\n            listingPrice\r\n        );\r\n    }\r\n    //update Listing\r\n    function updateListing(\r\n        address collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 listingPrice\r\n    ) public {\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n        require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n        require(owner == msg.sender, \"User is not the owner of the tokken\");      \r\n        s_Marketpalceitem memory item = _s_marketplaceItem[msg.sender][collectionAddress][tokenId];\r\n\r\n        require(\r\n            item.approval== true                         \r\n            ,\r\n            \"Marketplace is not approved to list items\"\r\n        );\r\n        require (item.Price== listingPrice,\"Listing Price cannot be same\");    \r\n        \r\n          \r\n        _s_marketplaceItem[msg.sender][collectionAddress][tokenId].Price = listingPrice;\r\n        \r\n        emit updatedListing(\r\n            msg.sender,\r\n            collectionAddress,\r\n            tokenId,\r\n            listingPrice\r\n        );\r\n    }\r\n\r\n\r\n    //buy available listings on the marketplace\r\n    function buyListing(\r\n        address collectionAddress,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId);\r\n        s_Marketpalceitem memory item = _s_marketplaceItem[owner][collectionAddress][tokenId];\r\n        require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n        require(\r\n            item.Price != (0),\r\n            \"Item is not listed on Marketplace\"\r\n        );\r\n        require(\r\n            item.approval == true,\r\n            \"Marketplace is not allowed to sell this tokken first createlisting on marketplace\"\r\n        );\r\n\r\n        require(\r\n            msg.value >= item.Price,\r\n            \"Amount send is less then the Price of the item.\"\r\n        );\r\n\r\n        //transfer tokken to msg.sender\r\n        IERC721(collectionAddress).transferFrom(owner, msg.sender, tokenId);\r\n        //transfer value to the owner of NFT\r\n        payable(owner).transfer(msg.value);\r\n        _s_marketplaceItem[msg.sender][collectionAddress][tokenId].approval = false;\r\n        emit listingSold(msg.sender, collectionAddress, tokenId, msg.value);\r\n    }\r\n\r\nfunction cancleListing(\r\n        address collectionAddress,\r\n        uint256 tokenId\r\n)public{\r\n     address owner = IERC721(collectionAddress).ownerOf(tokenId);\r\n\r\n        require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n        require(owner == msg.sender, \"User is not the owner of the tokken\");\r\n        _s_marketplaceItem[msg.sender][collectionAddress][tokenId].approval = false;\r\n\r\n        emit listingCancled(msg.sender,collectionAddress,tokenId);\r\n}\r\n\r\n function createOffer(\r\n        address collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 duration\r\n    ) public payable{\r\n        require(msg.value==(Price *1000000000000000000),\"Amount send must be equal to the Price of Offer\");\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n       \r\n        \r\n        require (duration> 86400,\"Duration cannot be less than 1 Day!\");\r\n\r\n        require(msg.sender!=owner,\"Owner cannot create Offer\");\r\n        s_Marketpalceoffer memory itemoffer = _s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId];\r\n        \r\n        require ( itemoffer.Price == (0),\"Offer already made must delete preious Offer\");\r\n        \r\n        uint256 Endtime = block.timestamp + duration;\r\n        \r\n        _s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId] =s_Marketpalceoffer(Price,Endtime);\r\n   \r\n        emit offerCreated(msg.sender,collectionAddress,tokenId,Price,Endtime);\r\n\r\n        }\r\nfunction updateOffer(\r\n        address collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        uint256 duration\r\n    ) public payable{\r\n        require(msg.value==(Price *1000000000000000000),\"Amount send must be equal to the Price of Offer\");\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n              \r\n        require (duration> 86400,\"Duration cannot be less than 1 Day!\");\r\n\r\n        require(msg.sender!=owner,\"Owner cannot create Offer\");\r\n       \r\n        s_Marketpalceoffer memory itemoffer = _s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId];\r\n        \r\n        require ( itemoffer.Price != Price,\"Offer already made with same price\");\r\n        \r\n        uint256 Endtime = block.timestamp + duration;\r\n        \r\n        _s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId] =s_Marketpalceoffer(Price,Endtime);\r\n   \r\n        emit offerUpdated(msg.sender,collectionAddress,tokenId,Price,Endtime);\r\n\r\n        }\r\n\r\n\r\nfunction acceptOffer(address offerer, address collectionAddress,uint256 tokenId)\r\n\r\npublic payable{\r\n        //No need check for end time since Item will not exit if time experired due to automation system\r\n        address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n        require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n        require(owner == msg.sender, \"User is not the owner of the tokken\");       \r\n        require(\r\n            IERC721(collectionAddress).isApprovedForAll(\r\n                msg.sender,\r\n                address(this)\r\n            )|| (IERC721(collectionAddress).getApproved(tokenId) == address(this)              \r\n            ),\r\n            \"Marketplace is not approved to Transfer items\"\r\n        );\r\n        //msg.sender is the owner of NFT\r\n        IERC721(collectionAddress).transferFrom(msg.sender,offerer,tokenId);\r\n\r\n        s_Marketpalceoffer memory itemoffer =_s_marketplaceItemoffer[offerer][collectionAddress][tokenId];\r\n\r\n        payable(owner).transfer(itemoffer.Price*1000000000000000000);\r\n        emit offerAccepted(offerer,collectionAddress,tokenId,itemoffer.Price,itemoffer.Endtime);\r\n        delete(_s_marketplaceItemoffer[offerer][collectionAddress][tokenId]);\r\n       \r\n\r\n}\r\nfunction cronJobOfferGarbageClean(address offerer,address collectionAddress,uint256 tokenId)public {\r\n    require(_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId].Endtime < block.timestamp,\"Time has not ended\");\r\n    \r\n    s_Marketpalceoffer memory itemoffer =_s_marketplaceItemoffer[offerer][collectionAddress][tokenId];\r\n    \r\n    payable(offerer).transfer(itemoffer.Price*1000000000000000000); \r\n    emit offerDeleted(msg.sender,collectionAddress,tokenId,itemoffer.Price,itemoffer.Endtime);\r\n    delete(_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId]);\r\n\r\n}\r\nfunction declineOffer(\r\n   address offerer,address collectionAddress,uint256 tokenId\r\n)\r\npublic {\r\n   address owner = IERC721(collectionAddress).ownerOf(tokenId); \r\n    require(\r\n            owner != address(0),\r\n            \"NFT doesn't exits in the Collection or on Blockchain\"\r\n        );\r\n    require(owner == msg.sender, \"User is not the owner of the tokken\"); \r\n      s_Marketpalceoffer memory itemoffer =_s_marketplaceItemoffer[offerer][collectionAddress][tokenId];\r\n\r\n    payable(offerer).transfer(itemoffer.Price*1000000000000000000);\r\n\r\n  \r\n\r\n    emit offerDeleted(offerer,collectionAddress,tokenId,itemoffer.Price,itemoffer.Endtime);\r\n    delete(_s_marketplaceItemoffer[offerer][collectionAddress][tokenId]);\r\n}\r\nfunction cancleOffer(address collectionAddress, uint256 tokenId) public payable{\r\n\r\n    require(_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId].Price!= 0,\"The item does not exit\");\r\n    payable(msg.sender).transfer(_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId].Price*1000000000000000000); \r\n    s_Marketpalceoffer memory itemoffer =_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId];\r\n    \r\n    emit offerDeleted(msg.sender,collectionAddress,tokenId,itemoffer.Price,itemoffer.Endtime);\r\n\r\n    delete(_s_marketplaceItemoffer[msg.sender][collectionAddress][tokenId]);\r\n}   \r\n\r\n//Private functions\r\n\r\n   function _makeItem(\r\n        address collectionAddress,\r\n        uint256 tokenId,\r\n        uint256 Price,\r\n        bool approval\r\n    ) private {\r\n        require(Price > 0, \"Price must be greater than zero\");\r\n        // New item is maped to the address of the owner\r\n        _s_marketplaceItem[msg.sender][collectionAddress][tokenId] = s_Marketpalceitem(\r\n            Price,\r\n            approval\r\n        );\r\n        emit itemCreation(\r\n            msg.sender,\r\n            collectionAddress,\r\n            tokenId,\r\n            Price,\r\n            approval\r\n        );\r\n    }\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}